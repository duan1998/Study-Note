# 程序的机器级表示

### 描述

计算机执行机器代码，用字节序列编码低级的操作，包括**处理数据**，**管理内存**，**读写存储设备上的数据**，以及利用**网络通信**。

### 过程

编译器基于编程语言的规则，目标机器的**指令集**和操作系统遵循的惯例，最后生成机器代码

例如GCC，GCC语言编译器以汇编代码的形式输出，汇编代码是机器代码的**文本表示**，然后GCC驱动程序调用汇编器和链接器，根据汇编代码生成可执行的机器代码

### 为啥子汇编语言以及机器语言直接用的少

高级语言的**抽象程序较高**，更有效率，优化做的好的编译器是可以将效率和汇编相提并论的，且有检错功能

另外一个点就是汇编是与**机器硬件的指令集**相关的，而高级语言可以**跨平台移植**

### 机器语言

**IA32**(Intel Architecture 32-bit->Inter 32位体系结构)以及最新的Intel64，即IA32的64位扩展，也称**x86-64**，**此前的系列统称为x86**

### 程序编码

##### 处理过程（C语言）

1. gcc驱动程序驱动**C预处理器**`cpp`扩展源代码**，插入所有用**#include命令指定的文件**，并扩展所有**用#define声明指定的宏**

```C
#define dprint（expr） printf（#expr “ = %/n”，expr）
//使用语句 dprint（x/y）;
//调用宏时，该宏将被扩展为：printf（“x/y”“ = %/n”，x/y）;
```

2. gcc驱动程序驱动**C编译器**`ccl`输出汇编代码
3. gcc驱动程序驱动**汇编器**`as`将**可读的文本表示**的汇编代码转换成**二进制目标代码文件**`.o`，但是此时的目标文件存在所有指令的二进制表示，却没有全局值的地址
4. gcc驱动链接器`ld`把所有目标模块链接起来，并重定位地址，最后输出可执行代码文件

##### **机器级代码**

两种对于机器级编程很重要的**系统抽象**

1. 由指令集体结构或**指令集架构**(Instruction Set Architecture,ISA) 来定义机器级程序的格式和行为，它定义了**处理器状态**，**指令的格式**，以及每条指令对状态的影响。（人话就是：程序该如何与系统交互，**使用什么规范**）
2. 机器级程序使用的内存是**虚拟内存**，提供的内存模型看上去是一个非常大的字节数组。（人话就是：将内存分配抽象成简单的物件）

##### **处理器状态**

###### 程序计数器

> `pc`，在x86-64机器语言中用**%rip**表示，作用是给出将要**执行**的下一条**指令**在**内存的地址**

###### 整数寄存器

> 包括**16**个命名的位置，分别存储**64位**的值
>
> 1. 可以存储地址（指针）或整数数据
> 2. 记录某些重要的程序状态
> 3. 用来保存临时数据，比如过程的参数，局部变量以及函数的返回值

###### 条件码寄存器

> 保存着最近执行的算数或逻辑指令的状态信息
>
> 用来实现控制数据流中的条件变化，比如说if while语句

###### 一组向量寄存器

> 一组向量寄存器可以存放一个或多个整数和浮点值

##### 程序内存

程序内存包含：

1. 程序的可执行代码（.text 二进制指令）
2. 操作系统需要的一些信息
3. 用来管理过程调用和返回的运行时栈
4. 用户分配的内存块（比如new或者malloc分配的）

##### 有效虚拟地址

程序内存使用虚拟地址来寻址，只有有限的一部分虚拟地址被认为是合法的，例如：x86-64的虚拟地址是由64位的字来表示的，这些地址的**高16位必须设置为0**，所以能够指定的是2^48或64TB范围内的一个字节。

操作系统负责管理虚拟地址空间，将**虚拟地址翻译成**实际处理器内存中的**物理地址**。

##### 机器指令

机器指令只执行基本的操作

1. 将存放在寄存器的两个数字相
2. 加，在存储器和寄存器之间传送数据
3. 条件分支转移到新的指令地址

##### C语言联合汇编语言

1. 使用汇编语言编写完整的函数，然后单独保存到其他文件中，使用汇编器和链接器将其和C程序链接在一起
2. 使用GCC的**内联汇编**(inline assembly)特性，使用**asm**伪指令可以在C中包含**简短的汇编代码**，**减少了与机器相关的代码量**

##### ATT与Inter汇编代码方式

//TODO page118



### 数据格式

###### 字`word`

由于是从**16位**体系结构扩展**32位的**，Inter用术语"字`word`"表示16位数据类型，8位是字节`byte`，32位成为双字`double words`，64位是四字 `quad words`

###### **汇编代码后缀**

C语言： char->`b` short->`w` int->`l` long->`q` char*->`q`  float->`s` double->`l`

大多数的GCC生成的汇编代码指令都有一个字符的后缀，表名操作数的大小  传送字节`movb`  传送字`movw` 传送双子`movl` 传送四字`movq`

以及汇编代码使用`l`来表示4字节**整数**和8字节**双精度浮点数**，不会产生歧义，因为浮点数使用的是**一组完全不同的指令和寄存器** 



### 访问信息(内存/寄存器)

1. 一个x86-64的中央处理单元`cpu`包含一组**16**个存储**64位值**的通用目的的**寄存器**，用来**存储整数数据和指针**（地址）

2. 该寄存器组的发展演变
   - 最初的8086中有8个16位的寄存器 从`%ax`到`%bp`
   - 扩展到IA32架构时，这8个寄存器也**扩展为32位寄存器**，标号从`%eax`到`%ebp`
   - 扩展到x86-64后，原来的8个寄存器**扩展成64位**，标号从`%rax`到`%rbp`，并增加了8个，标号从`%r8`到%`r15`

3. **整数寄存器以及其各自的目的**，所有16个寄存器的低位部分都可以作为字节`8位`，字`16位`，双字`32位`，四字`64位`来访问

| 63     | 31      | 15      | 7       |              |
| ------ | ------- | ------- | ------- | ------------ |
| `%rax` | `%eax`  | `%ax`   | `%al`   | 返回值       |
| `%rbx` | `%ebx`  | `%bx`   | `%bl`   | 被调用者保存 |
| `%rcx` | `%ecx`  | `%cx`   | `%cl`   | 第4个参数    |
| `%rdx` | `%edx`  | `%dx`   | `%dl`   | 第3个参数    |
| `%rsi` | `%esi`  | `%si`   | `%sil`  | 第2个参数    |
| `%rdi` | `%edi`  | `%di`   | `%dil`  | 第1个参数    |
| `%rbp` | `%ebp`  | `%bp`   | `%bpl`  | 被调用者保存 |
| `%rsp` | `%esp`  | `%sp`   | `%spl`  | 栈指针       |
| `%r8`  | `%r8d`  | `%r8w`  | `%r8b`  | 第5个参数    |
| `%r9`  | `%r9d`  | `%r9w`  | `%r9b`  | 第6个参数    |
| `%r10` | `%r10d` | `%r10w` | `%r10b` | 调用者保存   |
| `%r11` | `%r11d` | `%r11w` | `%r11b` | 调用者保存   |
| `%r12` | `%r12d` | `%r12w` | `%r12b` | 被调用者保存 |
| `%r13` | `%r13d` | `%r13w` | `%r13b` | 被调用者保存 |
| `%r14` | `%r14d` | `%r14w` | `%r14b` | 被调用者保存 |
| `%r15` | `%r15d` | `%r15w` | `%r15b` | 被调用者保存 |

4. 当指令以寄存器为目标时
   - 生成1字节，2字节数字的指令会保持**剩下的字节**不变（就是一个寄存器有8字节的空，要是占用的小了，就不用清空其他字节位置的数值）
   - 生成4字节数字的指令会把**高位4个字节置为0**
5. 栈指针`%rsp`，用来指明**运行时栈**的结束位置
6. 有一组标准编程规范控制着如何使用**寄存器**来**管理栈**，**传递函数参数，从函数的返回值，以及存储局部和临时数据**

7. 指令存在一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置

8. 源数据值可以以常数形式，或者从寄存器和内存中读出，结果可以存放在寄存器或内存中

9. 根据上一条，操作数类型分为三种
   - 立即数`immediata`  在ATT格式的汇编代码中，立即数的书写方式是`$`后面跟一个用标准C表示法表示的整数  如 $-577，**不同的指令允许的立即数范围不同**
   - 寄存器`register` 表示某个寄存器的内容，**16个寄存器的低位1字节，2字节，4字节，8字节中的一个作为操作数**，分别对应8位，16位，32位和64位。用符号r<sub>a</sub>来表示任意寄存器a，用引用R[r<sub>a</sub>]来表示他的值，将寄存器看成一个数组，寄存器标识作为索引
   - 内存引用，使用有效地址访问某个内存位置，由于将内存看成字节数组，用符号M<sub>b</sub>[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用，对于内存引用，存在多种不同的寻址模式。`Imm`(`r`<sub>b</sub>,`r`<sub>i</sub>,`s`)：一个立即数偏移Imm，一个基址寄存器`r`<sub>b</sub>，一个变址寄存器`r`<sub>i</sub>和一个比例因子`s`，**s={1,2,4,8}**，且**基址和变址寄存器必须是64位寄存器**，有效地址计算为Imm+R[r<sub>b</sub>]+R[r<sub>i</sub>]*s

10. 操作数格式

| 类型   | 格式                               | 操作数值                                   | 名称                |
| ------ | ---------------------------------- | ------------------------------------------ | ------------------- |
| 立即数 | $Imm                               | Imm                                        | 立即数寻址          |
| 寄存器 | r<sub>a</sub>                      | R[r<sub>a</sub>]                           | 寄存器寻址          |
| 存储器 | Imm                                | M[Imm]                                     | 绝对寻址            |
| 存储器 | (r<sub>a</sub>)                    | M[R[(r<sub>a</sub>)]]                      | 间接寻址            |
| 存储器 | Imm(r<sub>b</sub>)                 | M[Imm+R[r<sub>b</sub>]]                    | （基址+偏移量）寻址 |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>)      | M[R[r<sub>b</sub>]+R[r<sub>i</sub>]]       | 变址寻址            |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>)   | M[Imm+R[r<sub>b</sub>]+R[r<sub>i</sub>]]   | 变址寻址            |
| 存储器 | (,r<sub>i</sub>,s)                 | M[R[r<sub>i</sub>]*s]                      | 比例变址寻址        |
| 存储器 | Imm(,r<sub>i</sub>,s)              | M[Imm+R[r<sub>i</sub>]*s]                  | 比例变址寻址        |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>,s)    | M[R[r<sub>b</sub>]+R[r<sub>i</sub>]*s]     | 比例变址寻址        |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>,s) | M[Imm+R[r<sub>b</sub>]+R[r<sub>i</sub>]*s] | 比例变址寻址        |

### 指令

##### **前置概念**

**零扩展**：没有被填充的剩余字节全部填充为0

**符号扩展**：没有被填充的剩余字节全部设置为该二进制值最高位数字，比如0xAA  其二进制为10101010 取其最高位1，扩展到高位置  结果为 FF FF FF AA

关于`S`，`D`，`I`，`R`

>  选一段IA32架构的描述
>
> The movabsq instuction only allows immediate data**(shown as I)** as the source value.Others allow immediate data,a register,or memory(**shown as S**).Some instuctions require the destination to be a register **(shown as R )**,while other allow both register and memory destinations**(shown as D)**

-----------------------------

##### **数据传送指令**

###### mov指令

- mov指令  `MOV S,D `   (movb(8位) movw(16位) movl(32位) movq(64位) movabsq(64位))

  > 1. mov指令的操作数如果是16个通用目的寄存器之一，寄存器部分的大小要和指令**最后一个字符指定的大小匹配**
  > 2. 如果为寄存器生成32位值的话，其高位部分**清0**，也即是movl 如果目的操作数是寄存器，那么该寄存器剩下高位32位会清0
  > 3. movq指令只能以**表示为32位补码数字的立即数**作为源操作数，然后将这个值**符号扩展**得到64位的值，放到目的位置
  > 4. movabsq不同于movq，能够**以任意64位`I`作为源操作数**，但是**只能以`R`作为目的**   即  **movabsq I,R**
  > 5. **不能够源和目的操作数都是内存**，可以拆分成两条命令，从内存到寄存器，从寄存器到内存

###### movz指令

- movz指令 `MOVZ S,R ` `S(零扩展)->R`   movzbw,movzbl,movzwl,movzbq,movzwq  

  > 1. 将较小的源复制到较大目的地时候使用
  > 2. movz指令destination只能是`R`
  > 3. 之所以没有movzlq，是因为movl指令默认高位清0，是一样的效果

###### movs指令

- movs指令 `MOVS S,R` `S(符号扩展)->R`  movsbw  movsbl  movswl  movsbq  movswq  movslq  **cltq**

  > 1. 将较小的源复制到较大目的地时候使用
  > 2. movz指令destination只能是`R`
  > 3. **cltq的效果只能是将标识为%eax符号扩展为%rax**

**压入弹出栈数据**

作用：可以将数据压入程序栈（在内存中）中以及从程序栈中弹出数据

前言：栈向下增长，**栈顶元素**的地址是所有栈中元素地址中**最低的**，栈指针`%rsp`存储着**栈顶元素的地址**，且pushq和popq都只有一个操作数，**压入的数据源和弹出的数据目的地**

- pushq 指令  `pushq S`  将四字压入栈

  > 栈指针减8，然后将值写到新的栈顶地址   故pushq %rbp <==> subq $8，%rsp         movq %rbp,(%rsp)

- popq 指令    popq D    将四字弹出栈

  > 栈指针加8，该值之后会被覆盖

-----------------------------

##### 算术和逻辑操作

| 指令     | 效果               | 描述         |
| -------- | ------------------ | ------------ |
| leaq S,D | D=-&S              | 加载有效地址 |
| INC D    | D=-D+1             | 加1          |
| DEC D    | D=D-1              | 减1          |
| NEG D    | D= -D              | 取负         |
| NOT D    | D=~D               | 取补         |
| ADD S,D  | D=D+S              | 加           |
| SUB S,D  | D=D-S              | 减           |
| IMUL S,D | D=D*S              | 乘           |
| XOR S,D  | D=D^S              | 异或         |
| OR S,D   | D=D\|S             | 或           |
| AND S,D  | D=D&S              | 与           |
| SAL k,D  | D=D<<k             | 左移         |
| SHL k,D  | D=D<<k             | 左移         |
| SAR k,D  | D=D>><sub>A</sub>k | 算数右移     |
| SHR k,D  | D=D>><sub>L</sub>k | 逻辑右移     |



###### 加载有效地址`leaq`

1. leaq  S->R ，**目的地必须是寄存器**，虽然是指令形式从内存读到寄存器，但是其并未真正引用内存，而是将有效地址存入寄存器   b=&a 类似
2. b=&a，这条指令可以为后续的内存引用产生指针（存储在寄存器中的地址），也可以简洁的描述**普通的算数操作**

###### 一元和二元操作

1. 一元操作的操作符可以是一个寄存器或者内存位置
2. 二元操作subq %rax,%rdx  解读为从%rdx中减去%rax，最终的值还是要写入%rdx中。所以说，第二操作数既是源操作数，又是目的操作数
3. 二元操作，当第二个操作数为内存地址时，处理器必须**从内存读出值**，执行操作，再**把结果写入内存**

###### 移位操作

1. 移位量可以是立即数，也可以是放在单字节寄存器%c1中（只允许以该寄存器作为操作数）