# 第二部分 编程实操

## 闭包

### 1. 前言

1. 在Lua语言中，函数是严格遵循词法定界`lexical scoping`的第一类值`first-class value` 
2. 第一类值意味着Lua语言中的函数与其他常见类型的值具有同等权限，可以被保存到变量中，可作为参数，可作为返回值
3. 词法定界意味着Lua语言中的函数可以访问包含其自身的外部函数的变量，完全支持lambda

### 2. 函数是第一类值

1. 函数构造器，就像表构造器样，返回一个函数 function (x) body end
2. **Lua中，所有的函数都是匿名的，比如print，实际上指的是保存该函数的变量**

### 3. 非全局函数

1. 函数不仅可以存储在全局变量中，还可以被存储在**表字段**和**局部变量**中，把函数存储在**表字段中是实现面向对象编程**的关键要素

   ```lua
   lib={
   	foo=function (x,y) return x+y end,
   	goo=function (x,y) return x-y end
   }
   --另一种写法
   lib={}
   function lib.foo (x,y) return x+y end
   function lib.goo (x,y) return x-y end
   ```

2. 当把一个函数存储到局部变量时，就得到了一个局部函数

3. 利用局部函数在定义的时候就递归调用自身的话，局部的函数还未定义，会尝试调用全局的同名函数而非局部

   ```lua
   local fact = function(n)
   	if n==0 then return 1
   	else return n*fact(n-1)  --有问题
   	end
   end
   --解决方案
   local fact   --先定义
   fact=...
   ```

4. 对于非全局函数，提供了语法糖去定义

   ```
   local function f(params)
   	body
   end
   --当被展开时
   local f; f=function(params) body end  --所以使用该语法糖不会出现上一条的问题
   ```

### 4. 词法定界

1. 当编写一个被其他函数B包含的函数A时，被包含的函数A可以访问包含其的函数B的所有局部变量，这种特性称为词法定界

2. 非局部变量:在闭包中，既不是全局变量又不是局部变量的叫做非局部变量(non-local variable)（由于历史原因，非局部变量也称上值）

3. ```lua
   ----闭包作为高阶函数的的参数
   function digitButtion (dight)
   	return Button{label=tostring(digit),action =function()
   												add_to_display(digit)
   											end
   	}
   end
   ----闭包重新定义函数 ，在重定义后，一个程序就只能通过新的受限版本来调用原来未受限制的函数版本了
   --写法一
   local oldSin=math.sin
   math.sin = function(x)
       return oldSin(x*(math.pi/180))
   end
   --写法二
   do   --利用do ... end代码段来限制局部变量oldSin的作用范围
       local oldSin=math.sin
       local k =math.pi/180
       math.sin=function(x)
           return oldSin(x*k)
       end
   end
   
   ```

## 模式匹配

### 1. 模式匹配

1. 给定将要匹配的模式，与特定字符串进行匹配
2. 简单搜索`plain search`则是将模式单纯的看成字符串搜索，个人理解是比如正则表达式就是模式，而如果把正则表达式简单看成是字符串的话，就属于简单搜索

### 2. 模式匹配的函数

1. string.find(targetStr,pattern,[startIndex],[isPlainSearch])    **如果没有第3个参数，是不能存在第四个参数**

   ```lua
   s= "hello world"
   i,j=string.find(s,"hello")
   print(i,j)                   -->1   5
   print(string.sub(s,i,j))     -->hello
   print(string.find(s,"world"))-->7   11
   i,j=string.find(s,"l")
   print(i,j)                   -->3   3
   print(string.find(s,"lll"))  -->nil
   ```

2. string.match(targetStr,pattern)  和string.find相似的功能，只不过返回的是目标字符串中与模式相匹配的那部分字符串

   ```lua
   date = "Today is 17/7/1990"
   d = string.match(date,"%d+/%d+/%d+")
   print(d)   -->17/7/1990
   ```

3. string.gsub(targetStr,pattern,replaceStr,[replaceCount])  将目标字符串中所有出现模式的地方换成替换字符串，默认是全部替换，可选参数可限制替换次数，**第二个返回值是替换的次数**

   ```lua
   s=string.gsub("all lii","l","x")
   print(s)                        -->axx xii
   s=string.gsub("all lii","l","x",1)
   print(s)                        -->axx lii
   ```

4. string.gmatch() 返回一个函数，通过返回的函数可以对字符串中所有出现的模式进行遍历

   ```lua
   s="some string"
   words={}
   for w in string.gmath(s,"%a+") do
   	words[#word+1]=w
   end
   ```

### 3. 模式

 1. Lua使用百分号`%`作为转义符，模式中有特殊含义的字符都需要被转义  比如模式为小括号  转义写法如下  %(%)

 2. 字符分类：模式中能够与一个特定集合中的任意字符相匹配的一项

    | .    | 任意字符             |
    | ---- | -------------------- |
    | %a   | 字母                 |
    | %c   | 控制字符             |
    | %d   | 数字                 |
    | %g   | 除空格外的可打印字符 |
    | %l   | 小写符号             |
    | %p   | 标点符号             |
    | %s   | 空白字符             |
    | %u   | 大写字符             |
    | %w   | 字母和数字           |
    | %x   | 十六进制数字         |

    以上符号的大写是与之对应的补集，比如%A代表非字母的字符

	3. 在字符集前加一个补字符`^`可以得到对应集合的补集   如 `[^0-9]`，以补字符开头的表示从字符串的开头开始匹配 `^%d`,以$结尾的表示匹配到字符串结尾

	   ```
      --检查是否以数字开头
       if string.find(s,"^%d") then...
       --检查字符串是否为一个没有多余前缀字符和后缀字符的整数
       if string.find(s,"^[+-]?%d+$") then ...
       ```
    
      
    
    4. 修饰符/限定符
    
    | +    | 重复一次或多次           |
    | ---- | ------------------------ |
    | *    | 重复零次或多次           |
    | _    | 重复零次或多次(最小匹配) |
    | ？   | 可选（出现零次或一次）   |
    
    5. 模式"%b"匹配成对的字符串，写法是"%bxy"，x作为起始字符，y作为结束字符，比如"%b()" 匹配的是左括号开始右括号结尾的字符串

### 4. 捕获

1. 通过把模式中需要捕获的部分放入到一对**圆括号**内指定捕获

2. 使用string.match进行捕获，会把所有捕获的值作为单独的结果返回

   ```lua
   pair = "name = Anna"
   key, value = string.match(pair, "(%a+)%s*=%s*(%a+)")
   print(key, value) -->name Anna
   ```

3. 使用%n来表示捕获的副本，可以把之前的捕获副本作为后续的模式，特别的，**%0指的是匹配出的模式副本**

   ```lua
   --为了在一个字符串中寻找一个由单引号或者双引号括起来的字串
   s = [[then he said: "it's all right!"]]    -->[[]]是为了表示这个是字符串
   q,quotedPart = string.match(s, "([\"'])(.-)%1")  
   print(quotedPart)    -->it's all right!
   print(q)             -->"
   ```

### 5. 替换

1. string.gsub的第三个参数可以是字符串，可以是函数，可以是表
2. 如果第三个参数是函数，则会在每次找到匹配时调用该函数，参数是捕获到的内容而返回值则被作为替换字符串，如果返回值为nil，则不替换
3. 如果第三个参数是表，会把**第一个捕获到的内容**作为键，然后将表中对应该键的值作为替换字符串，如果不包含该键或者是该键对应的值为nil，则不替换

## 日期和时间

### 1. 日期表字段

```
year month day hour min sec
wday --表示本周中的第几天 第1天是星期天
yday --表示当年中的第几天 第1天是1月1日
isdst--boolean，如果使用夏时令则为真
```

### 2. 函数os.time

1. 没有参数调用的话会返回当前的日期和时间以数字的形式

   ```lua
   os.time()   -->1439653520
   os.time({year=2015,month=8.day=15,hour=12,min=45,sec=20})  -->1439653520
   ```

### 3. 函数os.date

1. 将一个表示日期和时间的数字转换为某些高级的表现形式，要么是日期表，要么是字符串

2. 两个参数，第一个参数表示形式的格式化字符串，第二个参数是数字形式的日期和时间，可选，没有的话表示当前时间

   ```lua
   os.date("*t",906000490) -->{year=1998,month=9,day=16,yday=259,wday=4,hour=23,min=78.sec=10,isdst=false}
   ```

## 位和字节

### 1. （未完待续）

## 数据结构

### 1. 数组

1. 在lua语言中，一般以1作为数组的起始索引，其标准库和长度运算符都遵循这个惯例，如果不从1开始，就不能使用这些机制

### 2. 字符串缓冲区

1. for循环使用`..`符号来拼接的话，因为字符串是常量，所以会不断开辟新的内存空间，然后复制过去，消耗大，可以**使用table，然后最后进行concat拼接**，变相实现**stringbuilder**

## 数据文件和序列化

### 1.数据文件

1. 如果需要自定义文件格式的话，可以把数据文件保存为lua文件，如下

   ```lua
   duanjinhui 182 71 
   zhangsan 182 70
   
   <==>
   data.lua
   
   Entry{
   	"duanjinhui",
   	"182",
   	"71"
   }
   Entry{
   	"zhangsan",
   	"182",
   	"70"
   }
   ```

   执行该文件，会调用Entry方法，Entry{code}和Entry({code})是相同的，只不过后者是以表为唯一参数的函数调用，需要使用data.lua数据时，可以先定义Entry函数，然后使用dofile(filename)来执行该文件，如下

   ```lua
   --下面的程序获取数据文件中所有人名，然后打印出来这些姓名
   local authors={}    --保存作者姓名的集合
   function Entry (b) authors[b[1]]=true end
   dofile("data")
   for name in pairs(authors) do print(name) end
   ```

2. **这个方式太强了！！！！！**

### 2. 序列化

1. 可以将序列化后的数据表示为Lua代码，当这些代码运行时，被序列化的数据就可以在读取过程中得到重建
2. 序列化数值时，用十进制格式保存浮点数可能**损失精度**，可以利用**十六进制格式来避免这个问题**，使用%a而不是%f

## 编译，执行和错误

### 1. 编译

1. 虽然Lua是解释型代码，但Lua语言总在运行前先预编译为中间代码（C语言中预编译的作用是插入所有用**#include命令指定的文件**，并扩展所有**用#define声明指定的宏**）
2. 区分解释型语言的点并不在于源码是否被编译，而在于能否有能力（且轻易的）执行动态生成的代码，可以说正是有了类似dofile这样的函数，才使得Lua语言能够被称为解释型语言
3. 