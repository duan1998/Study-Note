# 第一部分 语言基础

## 语言入门

### 1. 程序段

1. Lua语言执行的每一段代码（一个文件或交互模式下的一行）称为一个程序段`chunk`，即一组命令或表达式组成的序列

### 2. 词法规范

1. 下划线+大写字母，诸如`_VERSION`这样的标识符通常被Lua用作特殊用途，应避免

2. 分号可用来分隔一行内多个语句，也可以用空格分隔，意思就是**分号可带不可带**

### 3. 全局变量

1. 无需定义即可使用，只不过其值为nil
2. 当把nil赋值给全局变量时，Lua会**回收**该全局变量占用的内存，just like 从来没出现过

### 4. 类型和值

1. **将除false和nil外的所有值视为真，特别地，零和空字符串也都是真**

## 数值

### 1. 数值常量

1. 整数值和浮点型值的类型都是“number”的，是可以相互转换的
2. 具有相同算数值的整型值和浮点类型值在lua语言中是相等的
3. **Lua5.3之后**是区分整形和浮点数类型的 ，但是他们的类型还都是number，只不过使用math.type(3)  会输出integer 而math.type(3.0)则是float

### 2. 算数运算

1. 为了避免两个整型值相除和两个浮点型值相除导致不一样的结果，除法运算操作的永远是浮点数且产生浮点型值的结果
2. Lua5.3针对整数除法引入了一个称为floor除法的新算术运算叫  `//`,其处理整数除法就像C语言一样，floor除法会对得到的商向负无穷取整，保证结果是整数。如果操作数都是整数，那么结果也是整数，否则就是浮点类型值（其值是一个整数）
3. 取模运算 a%b==(a-(a//b)*b)，其结果的符号永远和b保持一致。对于任意指定的正常量K，即使x是负数，表达式x%K的值也永远在[0,K-1]之间
4. 实数类型的操作数而言，取模运算x-x%0.01恰好是x保留两位小数的结果，x-x%0.001则是保留3位

### 3. 惯例

1. 通过增加0.0的方法将整型值强制转换为浮点类型值   -3+0.0 ，小于2<sup>53</sup>即`9007199254740992`的所有整型值的表示和双精度浮点类型的表示一样，对于绝对值超过了这个值的整型值而言，在将其强制转换为浮点类型值时可能导致**精度损失**
2. 通过与0进行按位或运算，可以把浮点型强制转换为整型值   3.14|0==3.00 ，如果超过了整型的范围则会报错，另外一种方式是使用math.tointeger，该函数会在无法转换为整型值**返回nil**

### 4. 兼容性

1. Lua5.3引入的整型值导致其相对于此前的Lua版本出现了一定的不兼容
2. Lua5.3支持的最大整数是2<sup>63</sup>，而Lua5.2支持的仅有2<sup>53</sup>
3. Lua5.2会将3.0格式化成3输出，而Lua5.3则会格式化为3.0

## 字符串

### 1. 强制类型转换

tonumber(str,16)  第二个参数是转成的进制，10可以省略

### 2.UTF-8编码

## 表

### 1. 表索引

a.x代表的是a["x"]，而a[x]则是由变量x对应的索引的表

```
a={}
a[2.0]=10
a[2]   --10   原因是Lua5.2将2.0格式化为2
```

### 2. 数组，列表，序列

1. Lua语言提供了获取序列（所有元素都不为nil）长度的操作符`#`，对于中间有nil的列表而言，序列长度操作符是不可靠的

### 3. 表标准库

1. 函数table.insert向序列的指定位置插入一个元素，其他元素后移。 如 table.insert(t,1,15) 成功插入元素15，如果不指定位置，会默认放在table最后
2. 函数table.insert删除指定位置的元素，如果没有指定位置，则删除最后一个
3. Lua5.3添加一个table.move函数，table.move(a,f,e,t)，将表a中从索引f到e的元素（收尾包含）移动到位置t上，还支持使用一个表作为可选的参数，将f到e的克隆到另一个表中 table.move(a,1,#a,1,{}) 从第一个位置插入到这个空表

## 函数

### 1. 函数

也称过程`procedure`或子例程`subroutine`

### 2. 多返回值

将函数调用用一对圆括号括起来可以强制其只返回一个结果

### 3.可变长参数函数

要遍历{...}的话，如果中间没有nil的话，是可以按照list那一套进行遍历的，但是如果存在nil，Lua语言提供了函数table.pack(...)，该函数将参数保存以及个数n并返回一个表。另外一种遍历函数是使用select，select(n,...)返回第n个参数，select("#",...)返回输入参数的个数

### 4.函数table.unpack

该函数的参数是一个数组，返回值为数组内所有的元素

1. 重要用途之一体现在泛型调用(generic call)机制中，对一个可变长度的函数来说，我可以用这个玩意存储好多套参数，然后**动态去调用**

### 5. 正确的尾调用

1. 当一个函数的最后一个动作是调用另一个函数而没有进行其他工作时，就形成了尾调用
2. 这样的话，当被调用的函数执行结束后，程序就不需要返回最初的调用者，使得在进行尾调用时不适用任何额外的栈空间，这就是**尾调用消除**
3. 所以如果基于这个，尾调用是永远不会栈溢出的

## 输入输出

### 1. 简单I/O模型

1. 示例

   ```lua
   file = io.input("test1.txt")    -- 使用 io.input() 函数打开文件
   
   repeat
       line = io.read()            -- 逐行读取内容，文件结束时返回nil
       if nil == line then
           break
       end
       print(line)
   until (false)
   
   io.close(file)                  -- 关闭文件
   
   --> output
   my test file
   hello
   lua
   ```

2. 简单模型虚拟了一个当前输入流`current input stream`和一个当前输出流`current output stream`，I/O库把当前输入流初始化为进程的标准输入，将当前输出流初始化为进程的标准输出，大白话意思就是分别设置下输入的文件和输出的文件，重定向下就行

3. 设置输入，输出使用io.input（只读）以及io.output（只写）

4. io.write可以读取任意数量的字符串（或数字）并将其写入输出流，和print不同的是，io.write不会添加例如换行等附加的字符，也可搭配使用string.formate

5. io.read参数

   | "a"   | 读取整个文件             |
   | ----- | ------------------------ |
   | "l"   | 读取下一行（丢弃换行符） |
   | "L"   | 读取下一行（保留换行符） |
   | "n"   | 读取一个数值             |
   | "num" | 以字符串读取num个字符    |

6. io.read("a")可从当前位置读取当前输入文件的全部内容，如果当前位置处于文件末尾或者文件为空，则返回一个**空字符串**

7. io.lines迭代器,返回下一行

8. io.read("n")如果在跳过了空格，仍然不能从当前位置读到数值（由于错误的格式或者已经到文件尾），则返回nil

9. io.read(0)是一个特例，常用于测试是否到达文件尾，**如果仍然有数据可供读取，它会返回一个空字符串**，否则，返回nil

10. 调用函数io.read()可以指定多个选项，函数会根据每个参数返回相应的结果，比如local n1,n2,n3=io.read("n","n","n")

### 2. 完整I/O模型

1. 示例

   ```lua
   local f = assert(io.open(filename,"r"))
   local t = f: read("a")
   f:close()
   ```

2. 使用函数io.open打开文件，两个参数，文件名，和打开模式，只读的`r`，只写的`w`，追加的`a`，表示打开二进制文件的`b`

3. 当打开发生错误时，该函数会在返回nil的时候返回一条错误信息及一个系统相关的错误码，检查错误的方法是使用函数assert，如果函数open执行失败，错误信息就会作为函数assert的**第二个参数**被传入，之后展示出来

4. 使用**冒号加read，write**进行操作



