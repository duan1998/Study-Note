# 第一部分 语言基础

## 语言入门

### 1. 程序段

1. Lua语言执行的每一段代码（一个文件或交互模式下的一行）称为一个程序段`chunk`，即一组命令或表达式组成的序列

### 2. 词法规范

1. 下划线+大写字母，诸如`_VERSION`这样的标识符通常被Lua用作特殊用途，应避免

2. 分号可用来分隔一行内多个语句，也可以用空格分隔，意思就是**分号可带不可带**

### 3. 全局变量

1. 无需定义即可使用，只不过其值为nil
2. 当把nil赋值给全局变量时，Lua会**回收**该全局变量占用的内存，just like 从来没出现过

### 4. 类型和值

1. **将除false和nil外的所有值视为真，特别地，零和空字符串也都是真**

## 数值

### 1. 数值常量

1. 整数值和浮点型值的类型都是“number”的，是可以相互转换的
2. 具有相同算数值的整型值和浮点类型值在lua语言中是相等的
3. **Lua5.3之后**是区分整形和浮点数类型的 ，但是他们的类型还都是number，只不过使用math.type(3)  会输出integer 而math.type(3.0)则是float

### 2. 算数运算

1. 为了避免两个整型值相除和两个浮点型值相除导致不一样的结果，除法运算操作的永远是浮点数且产生浮点型值的结果
2. Lua5.3针对整数除法引入了一个称为floor除法的新算术运算叫  `//`,其处理整数除法就像C语言一样，floor除法会对得到的商向负无穷取整，保证结果是整数。如果操作数都是整数，那么结果也是整数，否则就是浮点类型值（其值是一个整数）
3. 取模运算 a%b==(a-(a//b)*b)，其结果的符号永远和b保持一致。对于任意指定的正常量K，即使x是负数，表达式x%K的值也永远在[0,K-1]之间
4. 实数类型的操作数而言，取模运算x-x%0.01恰好是x保留两位小数的结果，x-x%0.001则是保留3位

### 3. 惯例

1. 通过增加0.0的方法将整型值强制转换为浮点类型值   -3+0.0 ，小于2<sup>53</sup>即`9007199254740992`的所有整型值的表示和双精度浮点类型的表示一样，对于绝对值超过了这个值的整型值而言，在将其强制转换为浮点类型值时可能导致**精度损失**
2. 通过与0进行按位或运算，可以把浮点型强制转换为整型值   3.14|0==3.00 ，如果超过了整型的范围则会报错，另外一种方式是使用math.tointeger，该函数会在无法转换为整型值**返回nil**

### 4. 兼容性

1. Lua5.3引入的整型值导致其相对于此前的Lua版本出现了一定的不兼容
2. Lua5.3支持的最大整数是2<sup>63</sup>，而Lua5.2支持的仅有2<sup>53</sup>
3. Lua5.2会将3.0格式化成3输出，而Lua5.3则会格式化为3.0

## 字符串

### 1. 强制类型转换

tonumber(str,16)  第二个参数是转成的进制，10可以省略

### 2. UTF-8编码

## 表

### 1. 表索引

a.x代表的是a["x"]，而a[x]则是由变量x对应的索引的表

```
a={}
a[2.0]=10
a[2]   --10   原因是Lua5.2将2.0格式化为2
```

### 2. 数组，列表，序列

1. Lua语言提供了获取序列（所有元素都不为nil）长度的操作符`#`，对于中间有nil的列表而言，序列长度操作符是不可靠的

### 3. 表标准库

1. 函数table.insert向序列的指定位置插入一个元素，其他元素后移。 如 table.insert(t,1,15) 成功插入元素15，如果不指定位置，会默认放在table最后
2. 函数table.insert删除指定位置的元素，如果没有指定位置，则删除最后一个
3. Lua5.3添加一个table.move函数，table.move(a,f,e,t)，将表a中从索引f到e的元素（收尾包含）移动到位置t上，还支持使用一个表作为可选的参数，将f到e的克隆到另一个表中 table.move(a,1,#a,1,{}) 从第一个位置插入到这个空表

## 函数

### 1. 函数

也称过程`procedure`或子例程`subroutine`

### 2. 多返回值

将函数调用用一对圆括号括起来可以强制其只返回一个结果

### 3.可变长参数函数

要遍历{...}的话，如果中间没有nil的话，是可以按照list那一套进行遍历的，但是如果存在nil，Lua语言提供了函数table.pack(...)，该函数将参数保存以及个数n并返回一个表。另外一种遍历函数是使用select，select(n,...)返回第n个参数，select("#",...)返回输入参数的个数

### 4.函数table.unpack

该函数的参数是一个数组，返回值为数组内所有的元素

1. 重要用途之一体现在泛型调用(generic call)机制中，对一个可变长度的函数来说，我可以用这个玩意存储好多套参数，然后**动态去调用**

### 5. 正确的尾调用

1. 当一个函数的最后一个动作是调用另一个函数而没有进行其他工作时，就形成了尾调用
2. 这样的话，当被调用的函数执行结束后，程序就不需要返回最初的调用者，使得在进行尾调用时不适用任何额外的栈空间，这就是**尾调用消除**
3. 所以如果基于这个，尾调用是永远不会栈溢出的

## 输入输出

### 1. 简单I/O模型

1. 示例

   ```lua
   file = io.input("test1.txt")    -- 使用 io.input() 函数打开文件
   
   repeat
       line = io.read()            -- 逐行读取内容，文件结束时返回nil
       if nil == line then
           break
       end
       print(line)
   until (false)
   
   io.close(file)                  -- 关闭文件
   
   --> output
   my test file
   hello
   lua
   ```

2. 简单模型虚拟了一个当前输入流`current input stream`和一个当前输出流`current output stream`，I/O库把当前输入流初始化为进程的标准输入，将当前输出流初始化为进程的标准输出，大白话意思就是分别设置下输入的文件和输出的文件，重定向下就行

3. 设置输入，输出使用io.input（只读）以及io.output（只写）

4. io.write可以读取任意数量的字符串（或数字）并将其写入输出流，和print不同的是，io.write不会添加例如换行等附加的字符，也可搭配使用string.formate

5. io.read参数

   | "a"   | 读取整个文件             |
   | ----- | ------------------------ |
   | "l"   | 读取下一行（丢弃换行符） |
   | "L"   | 读取下一行（保留换行符） |
   | "n"   | 读取一个数值             |
   | "num" | 以字符串读取num个字符    |

6. io.read("a")可从当前位置读取当前输入文件的全部内容，如果当前位置处于文件末尾或者文件为空，则返回一个**空字符串**

7. io.lines迭代器,返回下一行

8. io.read("n")如果在跳过了空格，仍然不能从当前位置读到数值（由于错误的格式或者已经到文件尾），则返回nil

9. io.read(0)是一个特例，常用于测试是否到达文件尾，**如果仍然有数据可供读取，它会返回一个空字符串**，否则，返回nil

10. 调用函数io.read()可以指定多个选项，函数会根据每个参数返回相应的结果，比如local n1,n2,n3=io.read("n","n","n")

### 2. 完整I/O模型

1. 示例

   ```lua
   local f = assert(io.open(filename,"r"))
   local t = f: read("a")
   f:close()
   ```

2. 使用函数io.open打开文件，两个参数，文件名，和打开模式，只读的`r`，只写的`w`，追加的`a`，表示打开二进制文件的`b`

3. 当打开发生错误时，该函数会在返回nil的时候返回一条错误信息及一个系统相关的错误码，检查错误的方法是使用函数assert，如果函数open执行失败，错误信息就会作为函数assert的**第二个参数**被传入，之后展示出来

4. 使用**冒号加read，write**进行操作，将他们当作**流对象的方法**来用

5. *三个句柄：io.stdin(标准输入流),io.stdout(标准输出流),io.stderr*(标准错误流)

6. 调用无参的io.input可以获取当前输入流，如果想要临时改变输入流，可如下

   ```lua
   local temp = io.input()  --保存当前输入流
   io.input("newinput")     --打开一个新的当前输入流
   --对新的输入流进行某些操作
   io.input():close()	     --关闭当前流
   io.input(temp)		     --恢复此前的当前输入流
   ```

7. io.read(args)实际上是io.input():read(args)的简写，即函数read是用在当前输入流上的，io.write也是在输出流上的

### 3. 其他文件操作

1. 函数io.tmpfile返回一个操作临时文件的句柄，该句柄是以读/写模式打开的。当程序运行结束后，该临时文件会被自动移除（删除）

2. 函数io.flush()将所有缓冲数据写入文件，或者当作方法f:flush()使用，以刷新流f

3. 函数setvbuf用于设置流的缓冲模式，第一个参数是字符串，"no"表示无缓冲，“full”表示缓冲区满时或者显式地刷新文件时才写入数据，“line”表示输出一直被缓冲直到遇到换行符或从一些特定文件中读到了数据，第二个可选的参数，用于指定缓冲区大小

4. 大多数系统中，标准错误流`io.stderr`是不被缓冲的，而标准输出流`io.stdout`按行缓冲，当向标准输出流写入了不完整的行，需要刷新流才能看到结果

5. 函数seek用来获取和设置文件的当前位置，常常使用f:seek(whence,offset)的形式，whence指定如何使用偏移的字符串，为"set"时，表示相对于文件开头的偏移，为"cur"时，表示相对文件当前位置的位移，为"end"时，表示相对文件尾部的位移，函数会以字节为单位，返回当前新位置在流中相对于文件开头的偏移。

6. whence的默认值是cur，offset的默认值为0。因此，调用file:seek()会返回到当前的位置且不改变当前位置；

   调用函数file:seek("set")会将位置重置到文件开头**并返回0**

   调用函数file:seek("end")会将当前位置重置到文件结尾**并返回文件的大小**

   下面演示在不修改当前的位置情况下获取文件大小：

   ```lua
   function fsize(file)
   	local current=file.seek()      --保存当前位置
   	local size=file.seek("end")	   --获取文件大小
   	file:seek("set",current)       --恢复当前位置
   	return size
   end
   ```

7. os.rename用于文件重命名，函数os.remove用于移除/删除文件，这两个函数处理的都是真实文件而非流，他们位于os库而非io库

### 4. 其他系统调用

1. os.exit用于终止程序的执行，该函数的第一个参数是可选的，表示该程序的返回状态，其值可以为一个数值(0表示执行成功)或者一个布尔值(true表示执行成功)，第二个参数也是可选，为true时会关闭Lua状态并调用析构器释放所占用的所有内存
2. 函数os.getenv用于获取某个环境变量，该函数的输入参数时环境变量的名称，没有则返回nil

### 5. 运行系统命令

1. 函数os.execute用于执行系统命令，等价于C中的system，该函数的参数为表示待执行命令的字符串，返回值为命令运行结束后的状态。其中第一个返回值是一个布尔类型，当为true时表示程序成功运行完成，第二个返回值是一个字符串，当为"exit"时表示程序正常运行结束，当为"signal"表示因信号而中断，第三个返回值是返回状态或者终结该程序的信号代码 如

   ```lua
   function createDir(dirname)
   	os.execute("mkdir "..dirname)
   end
   ```

2. 函数io.popen同函数os.execute一样，运行一条系统命令，但是该函数还可以重定向命令的输入和输出

   ```lua
   local f = io.popen("dir /B","r")
   local dir={}
   for entry in f:lines() do
   	dir[#dir+1]=entry
   end
   ```

   其中，第二个参数"r"表示从执行的结果中读取，可选

   