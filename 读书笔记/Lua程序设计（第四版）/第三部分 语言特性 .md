# 第三部分 语言特性 

## 迭代器和泛型for

### 1. 迭代器和闭包

1. 迭代器`iterator`是一种可以遍历一个集合中所有元素的代码结构 
2. 闭包是一个可以访问其**自身的环境**中一个或多个局部变量的函数

### 2. 泛型for的语法

1. for做的第一件事就是对表达式进行求值，表达式应该返回三个值供for保存：**迭代函数，状态常量，控制变量的初始值**，”多退少补“ ，返回的值第一个（或 唯一一个）变量称为控制变量`control variable` ，其值为nil时表示循环结束

2. 将**状态常量和控制变量**作为参数调用**迭代函数**

3. **无状态的迭代器**：如果需要保存的变量只有状态常量和控制变量，那么无状态的迭代器是通过泛型for去保存这两者的，那么就可以通过调用函数而不是闭包了，在不需要更多需要保存的变量时，这样做比直接用闭包更省，此时迭代函数不等于闭包，只是普通函数，因为**每一个新的不保存状态循环都要创建一个新的闭包，就会多一份数据拷贝**

   ```lua
   --无状态 实现
   for var_1,...,var_n in explist do block end
   --等价于
   do
       local _f,_s,_var=explist
       while true do
           local var_1,...,var_n=_f(_s,_var)     --由此可见，可以返回多个值，但是只有第一个属于控制变量，用来判定是否循环结束
           _var=var1
           if _var==nil then break end
           block
       end
   end
   --显然 _f为迭代函数，不过是不需要保存状态的，_s为状态常量，比如表，_var是控制变量
   ```

4. **有状态的迭代器**：需要额外保存状态时，使用闭包去封存

### 3. 迭代器真正含义

1. 真正的迭代是在for循环完成的，迭代器是为每次的迭代提供连续的值，或许称之为生成器`generator`

2. 真正的迭代器

   ```lua
   function allwords(f)
       for line in io.lines() do
           for word in string.gmatch(line,"%w+") do
               f(word)   --调用函数
           end
       end
   end
   allwords(print)  --与for等价
   ```

## 元表和元方法

### 1. 元表

1. 元表可以修改一个值在面对一个位置操作时的行为，当Lua语言试图将两个表相加时，首先会检查两者之一是否有元表`metatable`且该元表是否有__add字段，如果有的话，调用该字段对应的元方法
2. 可以认为，元表是面向对象领域中的**受限制类**，像类一样，元表定义的是**实例行为**，因为只能给出**预先定义的操作集合**的行为，所以**受限**