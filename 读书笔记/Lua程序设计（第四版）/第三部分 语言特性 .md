# 第三部分 语言特性 

## 迭代器和泛型for

### 1. 迭代器和闭包

1. 迭代器`iterator`是一种可以遍历一个集合中所有元素的代码结构 
2. 闭包是一个可以访问其**自身的环境**中一个或多个局部变量的函数

### 2. 泛型for的语法

1. for做的第一件事就是对表达式进行求值，表达式应该返回三个值供for保存：**迭代函数，状态常量，控制变量的初始值**，”多退少补“ ，返回的值第一个（或 唯一一个）变量称为控制变量`control variable` ，其值为nil时表示循环结束

2. 将**状态常量和控制变量**作为参数调用**迭代函数**

3. **无状态的迭代器**：如果需要保存的变量只有状态常量和控制变量，那么无状态的迭代器是通过泛型for去保存这两者的，那么就可以通过调用函数而不是闭包了，在不需要更多需要保存的变量时，这样做比直接用闭包更省，此时迭代函数不等于闭包，只是普通函数，因为**每一个新的不保存状态循环都要创建一个新的闭包，就会多一份数据拷贝**

   ```lua
   --无状态 实现
   for var_1,...,var_n in explist do block end
   --等价于
   do
       local _f,_s,_var=explist
       while true do
           local var_1,...,var_n=_f(_s,_var)     --由此可见，可以返回多个值，但是只有第一个属于控制变量，用来判定是否循环结束
           _var=var1
           if _var==nil then break end
           block
       end
   end
   --显然 _f为迭代函数，不过是不需要保存状态的，_s为状态常量，比如表，_var是控制变量
   ```

4. **有状态的迭代器**：需要额外保存状态时，使用闭包去封存

### 3. 迭代器真正含义

1. 真正的迭代是在for循环完成的，迭代器是为每次的迭代提供连续的值，或许称之为生成器`generator`

2. 真正的迭代器

   ```lua
   function allwords(f)
       for line in io.lines() do
           for word in string.gmatch(line,"%w+") do
               f(word)   --调用函数
           end
       end
   end
   allwords(print)  --与for等价
   ```

## 元表和元方法

### 1. 元表

1. 元表可以修改一个值在面对一个位置操作时的行为，当Lua语言试图将两个表相加时，首先会检查两者之一是否有元表`metatable`且该元表是否有__add字段，如果有的话，调用该字段对应的元方法

2. 可以认为，元表是面向对象领域中的**受限制类**，像类一样，元表定义的是**实例行为**，因为只能给出**预先定义的操作集合**的行为，所以**受限**

3. 在lua语言中，只能为表设置元表，必须通过C代码或者调试库完成为**其他类型的值**设置元素

4. 字符串标准库为所有的字符串都设置了同一个元表，而其他类型默认都是没有元表

   ```lua
   print(getmetatable("hi"))     -->table: 0000023D68D90990
   print(getmetatable("str"))    -->table: 0000023D68D90990
   print(getmetatable(10))       -->nil
   print(getmetatable(print))    -->nil
   ```

### 2. 算数运算相关的元方法

| 加法       | __add    |
| ---------- | -------- |
| 乘法       | __mul    |
| 减法       | __sub    |
| 除法       | __div    |
| floor除法  | __idiv   |
| 负数       | __unm    |
| 取模       | __mod    |
| 幂运算     | __pow    |
| 按位与     | __band   |
| 按位或     | __bor    |
| 按位异或   | __bxor   |
| 按位取反   | __bnot   |
| 向左移位   | __shl    |
| 向右移位   | __shr    |
| 连接运算符 | __concat |

1. 当一个表达式中混入了两种具有不同元表的值时，如果第一个值有元表并且有对应的元方法，那么就是用这个方法，如果不行，看第二个值，如果还不行的话就抛出异常

### 3. 关系运算相关的元方法

1. 包括等于`__eq`，小于`__lt`，小于等于`__le`  Lua语言会将a~=b转为not(a==b)，a>b转换为b<a，a>=b转换为b<=a

2. 标准规定0/0的值为NaN，任何涉及NaN的比较都应返回假

   ```lua
   mt.__le=function(a,b)
       	for k in pairs(a) do
           	if not b[k] then return false end
            end
       return true
   end
   
   mt.__lt=function(a,b)
       return a<=b and not (b<=a)
   end
   
   mt.__eq=function(a,b)
       return a<=b and b<=a
   end
   ```

### 4. 库定义相关的元方法

1. print用的是__tostring

2. getmetatable和setmetatable也用到了元方法，用于保护元表，如果在元表中设置__metatable字段的话，用户既不能看到也不能修改集合的**元表**

   ``` lua
   mt.__metatable="not your business"
   s1=Set.new{}
   print(getmetatable(s1))     -->not your business
   setmetatable(s1,{})         -->stdin:1:cannot change protected metatable
   ```

3. 5.2之后，pairs也有对应的元方法，可以修改表被遍历的方式和为非表增加便利行为 __pairs 

### 5. 表相关的元方法

1. \_\_index元方法和\_\_newIndex方法类似于C#中属性的get和set方法，但是触发的前提是**当前的表无法找到对应的索引**，\_\_index字段触发时，如果该字段的值为表时，返回对应的value（not exist return null），如果为方法，则调用该方法  